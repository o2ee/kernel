在这一个章节中，我们将说明Linux系统上的汇编的基本使用，以方便理解内核模块中的少量汇编。

首先我们了解下汇编语言与二进制的关系：

计算机课本里面经常出现：

A：计算机里面存储的都是0 ，1， 0， 1。

B：计算机执行的程序都是汇编语言

这两者是什么关系呢？

一、

我们先来说说B

其实B里所说的汇编语言，就是CPU指令。

CPU的基础指令，学过汇编语言的都知道：

例如：

赋值 move AX,0 #这里AX 是cpu内部的存储器，就是存放数据的。

这条语句就是 将 0 给AX，

当这条语句执行后，AX里面就是0了。

二、

我们再来说说A和B的关系。

那么move AX,0这种写法，我们自己就能看懂。

其实CPU是看不懂的，A说法的描述了，CPU懂得0，1，0，1；

怎么让CPU看懂呢？

结果就是这条指令经过程序编译后的代码：

b8 00 00 00 00
汇编之Hello world

.section .data
	msg:.ascii "hello,world !\n"
	len = .-msg
.section .text
	.globl main
main:
	pushl	$msg
	call 	printf
	addl	$4, %esp
	pushl	$0
	call	exit
$ gcc hello.s -o hello 
$ ./hello
hello,world !

汇编器的命令选项

as [[option]] [-o output] file

命令行常用参数选项含义：

参数 描述

-a 指定输出中包含哪些清单

-f 快速汇编，跳过注释和空白

-gstabs 包含每行源代码的调试信息

-gstabs+ 包含专门的gdb调试信息

-I 指定搜索包含头文件的目录

-o 指定输出目标文件的名称

-R 把数据段合并到文本段

-statistics 显示汇编使用的最大空间和总时间

-v 显示as的版本号

-W 不显示警告信息

-- 对于源文件使用标准输入

OBJDUMP 反汇编器

反汇编和汇编器是两个互逆的过程，后者将汇编源文件转化为机器语言，前者将机器语言转换成汇编语言

格式： objdump [[option]] [[objfile]]

-a 如果文件是存档文件，则显示存档头文件

-b 指定目标代码文件的目标代码格式

-d 将目标代码反汇编为指令代码

-D 将目标代码的所有段反汇编为指令码

-G 显示调试段的内容

-l 使用源代码行号标记输出

-s 显示指定段的内容

-S 交错显示源代码和反汇编后的代码

-x 显示所有可用的头信息

$ objdump -D hello
LD 链接器的命令选项

链接器LD用于把目标代码文件链接成可执行文件或者库文件

ld [[optional]] [-o output] objfile

参数 描述

-b 指定目标代码输入文件的格式

-Bstatic 只使用静态库

-Bdynamic 只使用动态库

-c 从指定的命令文件读取命令

-dynamic-link	指定动态链接库

-e 使用指定的符号作为程序的初始执行点

-l 把指定的存档文件添加到要链接的文件清单中

-L 把指定的路径添加到搜索库的目录清单中

-n 设置文本段只读

-O 生成优化了的输出文件

-o 指定输出文件的名称

-oformat 指定输出文件的二进制格式

-rpath 把指定目录添加到运行时库搜索路径

-rpath-link 指定搜索运行时共享库的目录

-shared 创建共享库

-Ttext 使用指定的地址作为文本段的起始点

-Tdata 使用指定的地址作为数据段的起始点

-Tbss	使用指定的地址作为bss段的超始点