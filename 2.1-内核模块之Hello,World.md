当我们写任何程序时，我们免不了使用Hello,world，当然为了让大家感觉不太诧异，在内核模块中 我们也使用Hello,world作为我们的第一个模块。。。

在学习编程时，我有一个体会是，通过一个个的小demo，自己边写边看，这样速度比较快，至于理论 我们可以往后放一放，待大家明白了，自然是水到渠成。。。

下面直接给demo
```
//-----------------------------------------------------------------
//	kello.c
//
//	This kernel module outputs a brief message to the console.
//
//		compile using: $ mmake hello 
//		install using: $ /sbin/insmod hello.ko
//
//	programmer: ALLAN CRUSE
//	written on: 23 AUG 2007
//-----------------------------------------------------------------
#include <linux/module.h>		// for printk()
static int __init init_hello( void )
{
	printk( "\n   Kello, everybody! \n\n" );
	return	0;
}
static void __exit exit_hello( void )
{
	printk( "\n   Goodbye now... \n\n" );
}
MODULE_LICENSE("GPL");
module_init(init_hello);
module_exit(exit_hello);
```
我们给这个文件起一个名字kello.c 为什么不是hello.c 因为这个hello运行在内核态。。。
那么这里有一个概念：
什么是内核态呢？ 提到这里大家肯定会想到，是不是还有另外一个态：当然有：用户态 当提到这两个态的时候大家可能会想到学习操作系统时的管态和目态，与这道理是相同的。。。 对于具体的区别请参见：
[http://book.51cto.com/art/201001/177431.htm](http://book.51cto.com/art/201001/177431.htm)
说了这么多还没开始呢：

`$ mmake kello.c`

这时我们将生成了一个kello.ko文件。。。这个文件就是我们要的东西。。。,同时生成我们的Makefile文件见下面：

```
ifneq ($(KERNELRELEASE),)
obj-m := kello.o
module-objs := module_address.o 
else
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)
default:
	$(MAKE) -C $(KDIR) M=$(PWD) modules
endif
```
大家看到与我们平常编程的区别了吗？ 文件的扩展名是 ＊.ko 这个k指的是kernel也就是内核态的.o 文件。 别忘了，还有一个Makefile文件，这个就是我们上节需要准备的Makefile 以后我们编译链接只需：
`$ make`
就OK了，多方便
现在.ko生成了，怎么样去执行它呢，好像./kello.ko不行呢。。。呵呵，当然不行，既然是内核 态的程序，当然有内核态的方法呢，怎么能和用户态程序一样的，那不太掉价了。。。。 看：
`$ sudo insmod kello.ko`
有提示则输入密码： 好了
怎么没有任何反应。。。开玩笑，在内核输出就是不一样。。。
看着
`$dmesg -c`
 
`[ 4049.943113] Kello, everybody!`
那么怎么卸载这个模块呢:
```
$ sudo rmmod kello
```
下面是网友提供的一个hello,world内核模块的例子，这个例更为详细的讲解了helloworld模块，
如果大家在上述例子中有不理解的，或不清楚的，可以参考以下例子。。。

网友提供的hello world 模块实例

下面简要说下内核态与用户态的区别？

关于内核态与用户态的区别，我在网上看到一篇文章非常的好
就像世界上的人并不平等一样，并不是所有的程序都是平等的。世界上有的人占有资源多，有的人占有资源少，有的人来了，别人得让出资源，有的人则专门为别人让出资源。程序也是这样，有的程序可以访问计算机的任何资源，有的程序则只能访问非常受限的少量资源。而操作系统作为计算机的管理者，自然不能和被管理者享受一样的待遇，它应该享有更多的方便或特权。为了区分不用程序的不同权利，人们发明了内核和用户态的概念。
那么什么是内核态，什么是用户态呢？只要想一想现实生活中，处于社会核心的人与处于社会边缘的人有什么区别就能明白处于核心的人拥有的资源多！因此，内核态就是拥有资源多的状态，或者说访问资源多的状态，我们也称之为特权态。相对来说，用户态就是非特权态，在此种状态下访问的资源将受到限制。如果一个程序运行在特权态，则该程序就可以访问计算机的任何资源，即它的资源访问权限不受限制。如果一个程序运行在用户态，则其资源需求将受到各种限制。

例如，如果要访问操作系统的内核数据结构，如进程表，则需要在特权态下才能办到。如果要访问用户程序里的数据，则在用户态下就可以了。
由于内核态的程序可以访问计算机的所有资源，这种程序的可靠性和安全性就显得十分重要。试想如果一个不可靠的程序在内核态下修改了操作系统的各种内核数据结构，结果会怎样呢？整个系统有可能崩溃。而运行于用户态的程序就比较简单了，如果其可靠性和安全性出了问题，其造成的损失只不过是让用户程序崩溃，而操作系统将继续运行。

很显然，内核态和用户态各有优势：运行在内核态的程序可以访问的资源多，但可靠性、安全性要求高，维护管理都较复杂；用户态程序访问的资源受限，但可靠性、安全性要求低，自然编写维护起来都较简单。一个程序到底应该运行在内核态还是用户态取决于其对资源和效率的需求。
一般来说，一个程序能够运行于用户态，就应该让它运行在用户态。只在迫不得已的情况下，才让程序运行于内核态。只要看看一个国家的治理就清楚了。我们拿什么标准来判断什么事情应该归国家领导管理。凡是牵扯到计算机本体根本运行的事情都应该在内核态下执行，只与用户数据和应用相关的东西则放在用户态执行。另外，对时序要求特别高的事情，也应该在内核态做。你有没有想过，国家领导出门怎么不塞车呢？
那么什么样的功能应该在内核态下实现呢？ 首先，CPU管理和内存管理都应该在内核态实现。这些功能可不可以在用户态下实现呢？当然能，但是不太安全。就像一个国家的军队（CPU和内存在计算机里的地位就相当于一个国家的军队的地位）交给老百姓来管一样，是非常危险的。所以从保障计算机安全的角度来说，CPU和内存的管理必须在内核态实现。

诊断与测试程序也需要在内核态下实现。因为诊断和测试需要访问计算机的所有资源，否则怎么判断计算机是否正常呢？就像中医治病，必须把脉触摸病人。你不让中医触摸，他怎么能看病呢（当然，很多人认为中医是伪科学，根本治不了病，本书对此问题不做讨论）？输入输出管理也一样，因为要访问各种设备和底层数据结构，也必须在内核态实现。
对于文件系统来说，则可以一部分放在用户态，一部分放在内核态。文件系统本身的管理，即文件系统的宏数据部分的管理，必须放在内核态，不然任何人都可能破坏文件系统的结构；而用户数据的管理，则可以放在用户态。编译器、网络管理的部分功能、编辑器用户程序，自然都可以放在用户态下执行。

参考文章： 
[http://book.51cto.com/art/201001/177431.htm](http://book.51cto.com/art/201001/177431.htm)